sum(apply(vls, 1, prod))/sum(vls[,2]))
}else{
vls <- numeric()
for(f in ras)
# if(!is.null(intersect(extent(raster(f)), extent(pol))) == TRUE)
if(file.exists(f))
#if extents overlap........
vls <- c(vls, extract(crop(raster(f),extent(pol)), pol)[[1]])
else{print('check for missing agb tiles...')}#################
if(length(na.omit(vls)) == 0) return(0)
AGB <- mean(vls, na.rm=T)
}
AGB
}
invDasymetry <- function(clmn = "ZONE", value = "Australia", aggr = NULL,
minPlots = 1, wghts = FALSE){
# returns a data.frame with (mean) AGB from plots satisfying selection
# criteria
# load plot data
plots <- read.csv(file.path(plotsFolder, plotsFile), T, stringsAsFactors = F)
# plots <- subset(plots, !is.na(plots$GEZ))
#  plots <- plots[c(1:5000),]
if(is.null(aggr)) # overrule minPlots if no aggregagtion
minPlots <- 1
# select plots fulfilling selection criterion set by attr and value
clm <- which(names(plots) == clmn)
if(length(clm)==0)
stop(paste('Attribute', attr, 'not found'))
ndx <- which(plots[,clm] == value)
if(length(ndx)==0)
stop('There are no records satisfying the selection criterion.')
plots <- plots[ndx,]
# aggregate if aggr != NULL
if(!is.null(aggr)){
# aggregate to aggr degree cells
plots$Xnew <- aggr * (0.5 + plots$POINT_X %/% aggr)
plots$Ynew <- aggr * (0.5 + plots$POINT_Y %/% aggr) #changes XY
plotsTMP <- aggregate(plots$AGB_T_HA, list(plots$Xnew, plots$Ynew),
mean, na.rm=T)
names(plotsTMP) <- c("POINT_X","POINT_Y","AGB_T_HA")
# only keep plots satisfying minPlots criterion
if(minPlots > 1){
blockCOUNT <- aggregate(plots$AGB_T_HA, list(plots$Xnew, plots$Ynew),
function(x) length(na.omit(x)))
ndx <- which(blockCOUNT$x >= minPlots)
plotsTMP <- plotsTMP[ndx,]
}
plots <- plotsTMP
rsl <- aggr
} else {
# determine resolution output
fname <- list.files(agbTilesFolder, "*.tif")[1]
rsl <- xres(raster(file.path(agbTilesFolder, fname)))
}
# sample forest fraction and AGB data per cell/plot
nc <- detectCores()
cl <- makeCluster(nc-1)
registerDoParallel(cl, nc)
FFAGB <- foreach(i=1:nrow(plots), .combine='rbind', .errorhandling = 'remove',
.packages='raster', .export=c('MakeBlockPolygon', 'SRS',
'sampleTreeCover', 'TCtileNames',
'AGBtileNames', 'sampleTreeCover',
'sampleAGBmap', 'plotsFile',
'agbTilesFolder', 'treeCoverFolder',
'forestTHs', 'checkAGB')) %dopar% {
pol <- MakeBlockPolygon(plots$POINT_X[i],
plots$POINT_Y[i], rsl)
if(is.null(aggr)){
if(is.na(plots$SIZE_HA[i])){
treeCovers <- sampleTreeCover(pol, forestTHs, wghts)
} else if(plots$SIZE_HA[i] >= 1){
# ***** if plot size equals 1 ha *****
treeCovers <- rep(1, length(forestTHs))
} else {
# ***** if plot size less than 1 ha *****
treeCovers <- sampleTreeCover(pol, forestTHs, wghts)
}
} else
treeCovers <- sampleTreeCover(pol, forestTHs, wghts)
wghts2 <- ifelse(is.null(aggr), FALSE, wghts)
c(treeCovers * plots$AGB_T_HA[i], plots$AGB_T_HA[i],
sampleAGBmap(pol, wghts2), plots$POINT_X[i],
plots$POINT_Y[i])
}
stopCluster(cl)
FFAGB <- data.frame(FFAGB)
names(FFAGB) <- c(paste0("plotAGB_", forestTHs), "orgPlotAGB",
"mapAGB", "x", "y")
return(FFAGB)
}
AGBdata <- invDasymetry("GEZ", "subtropical", 0.1, 5)
summary(AGBdata)
AGBdata
if (grepl('Baccini', agbTilesFolder) == 1){
checkAGB <-print('Using Baccini tiles')}
if (grepl('Baccini', agbTilesFolder) == T){
checkAGB <-print('Using Baccini tiles')}
AGBtileNames <- function(pol){
bb <- unname(bbox(pol))
crds <- expand.grid(x=bb[1,],y=bb[2,])
fnms <- character(4)
for(i in 1:nrow(crds)){
if (grepl('Baccini', agbTilesFolder) == TRUE){
checkAGB <-print('Using Baccini tiles')
lon <- 10*(crds[i,1]%/%10)
lat <- 10*(crds[i,2]%/%10) + 10
LtX <- ifelse(lon < 0, "W", "E")
LtY <- ifelse(lat < 0, "S", "N")
WE <- paste0(sprintf('%03d',abs(lon)), LtX)
NS <- paste0(sprintf('%02d',abs(lat)), LtY)
fnms[i] <- file.path(agbTilesFolder, paste0(NS, "_", WE,"_biomass.tif"))
}else if (grepl('Avitabile', agbTilesFolder) == TRUE){
print('Using Avitabile tiles')
lon <- 10*(crds[i,1]%/%10)
lat <- 10*(crds[i,2]%/%10) + 10
LtX <- ifelse(lon < 0, "W", "E")
LtY <- ifelse(lat < 0, "S", "N")
WE <- paste0(sprintf('%03d',abs(lon)), LtX)
NS <- paste0(sprintf('%02d',abs(lat)), LtY)
fnms[i] <- file.path(agbTilesFolder, paste0(NS, "_", WE,"_merge.tif"))
}
else{
print('Using GlobBiomass/GEOCARBON tiles')
lon <- 2*(crds[i,1]%/%2)
lat <- 2*(crds[i,2]%/%2) + 2
LtX <- ifelse(lon < 0, "W", "E")
LtY <- ifelse(lat < 0, "S", "N")
WE <- paste0(LtX, sprintf('%03d',abs(lon)))
NS <- paste0(LtY, sprintf('%02d',abs(lat)))
fnms[i] <- file.path(agbTilesFolder, paste0(NS,WE,"_agb_100m.tif")) #applicable to GlobBiomass and GEOCARBON
}
}
unique(fnms)
}
library(raster)
install.packages("raster")
install.packages("raster")
packages <- c("raster", "ggplot2", "devtools", "ggpmisc", "cowplot", "ggpubr")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
install.packages("raster", lib="C:/Program Files/R/R-3.4.3/library")
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())))
}
?install.packages
?setdiff
.libPaths()
.libPaths()[2]
install.packages(setdiff(packages, rownames(installed.packages()), destdir=.libPaths()[2]))
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(destdir=.libPaths()[2], setdiff(packages, rownames(installed.packages())))
}
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages( setdiff(packages, destdir=.libPaths()[2],rownames(installed.packages())))
}
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages()),destdir=.libPaths()[2],))
}
install.packages(setdiff(packages, rownames(installed.packages()),destdir=.libPaths()[2]))
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages()),destdir=.libPaths()[2]))
}
installed.packages()
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages,destdir=.libPaths()[2], rownames(installed.packages())))
}
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())),destdir=.libPaths()[2])
}
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())),lib=.libPaths()[2])
}
?crop
library(setdiff(packages))
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())),lib=.libPaths()[2])
lapply(packages, library, character.only = TRUE)
}
?crop
if (length(setdiff(packages, rownames(installed.packages()))) > 0) {
install.packages(setdiff(packages, rownames(installed.packages())),lib=.libPaths()[2])
lapply(packages, require, character.only = TRUE)
}
?crop
lapply(packages, require, character.only = TRUE)
lapply(packages, library, character.only = TRUE)
?crop
options(shiny.maxRequestSize = 30*1024^2)
# packages
library(shiny)
library(DT)
library(rgdal)
library(raster)
library(plyr)
library(dplyr)
library(foreach)
library(parallel)
library(doParallel)
library(plotrix)
library(Metrics)
# global variables
dataDir <- "M:/BiomassCCI/Shiny/data"
scriptsDir <- "M:/BiomassCCI/Shiny/R"
mainDir <- "M:/BiomassCCI_2019"
outDir <- "M:/BiomassCCI/Shiny/results"
agbTilesDir <- "M:/BiomassCCI/data/agb"
treeCoverDir <- '//GRS_NAS_01/GRSData/global_products/Hansen/treecover_2010/treecover2010_v3' # make sure of folder access
SRS <- CRS("+init=epsg:4326")
forestTHs <- 10 # for
# functions
setwd(scriptsDir)
source('Overview.R')
source('TempFixed.R')
source('TempEffect.R')
source('MakeBlockPolygon.R')
source('TileNames.R')
source('BlockMeans.R')
source('invDasymetry.R')
source('OnePlot_450.R')
source('Accuracy.R')
source('ThreePlots.R')
#ui
ui <- fluidPage(
#title
titlePanel(p("Validation app", style = "color:#3474A7")),
#sides
sidebarLayout(
sidebarPanel(width=2,
fileInput(inputId = "filedata", label = "Upload data. Choose csv file",
accept = c(".csv")),
# scale options
selectInput(inputId = "scale", label = "Plot AGB is intercontinental?",
choices = c("local", "global")),
# Only show this panel if plot data is intercontinental
conditionalPanel(
condition = "input.scale == 'global'",
selectInput(inputId = "global", label = "What scale?",
c('country', 'biome')),# multiple = TRUE),
verbatimTextOutput("global")
),
# If intercontinental, chose between continents and biomes
conditionalPanel(
condition = "input.scale == 'global'",
selectInput(inputId = "subglobal", label = "What sub-scale?", ""), #will be updated after plot upload
verbatimTextOutput("subglobal")
),
# plot overview
conditionalPanel(
condition = "input.scale == 'global'",
selectInput(inputId = "overview", label = "Overview field",
choices = c("fez", "year")),
verbatimTextOutput("overview")
),
# see temporal fix effect
radioButtons(inputId = "temporal", label = "Apply Temporal fix?",
choices = c("yes", "no"),selected = character(0)),
# aggregation level
radioButtons(inputId = "aggregation", label = "Apply Aggregation?",
choices = c("yes", "no"),selected = character(0)),
# Only show this panel if to apply aggregation
conditionalPanel(
condition = "input.aggregation == 'yes'",
numericInput("obs1", "Aggregation:", 0.1, min = 0.001, max = 1),
verbatimTextOutput("agg")
),
# run another output
radioButtons(inputId = "comparison", label = "show effects?",
choices = c("yes", "no"),selected = character(0))
),
#body
mainPanel(
tabsetPanel(
#overview
tabPanel("Overview",
plotOutput("graph"),
DTOutput("table")),
#add tab for temporal fix
tabPanel("Temporal fix",
plotOutput("hist"),
DTOutput("table1")),
#add tab for aggregation and forest fraction
tabPanel("Main",
plotOutput("valid1"),
DTOutput("accuracy1"),
plotOutput("valid2")
# DTOutput("accuracy2"),
#plotOutput("valid3"),
#DTOutput("accuracy3")
)
)
)
)
)
# server()
server <- function(input, output, session) {
#make table reactive
data <- reactive({
req(input$filedata)
df <-read.csv(input$filedata$datapath)
#update subscale inputs
# retrieve zoning groups
continent <- unique(na.omit(df$ZONE))
biome <- unique(na.omit(df$GEZ))
if (input$global == 'country'){
updateSelectInput(session, inputId = 'subglobal', label = "What sub-scale?",
choices = continent, selected = "")}
else{
updateSelectInput(session, inputId = 'subglobal', label = "What sub-scale?",
choices = biome, selected = "")
}
return(df)
})
#loads table
output$table <- renderDT(data())
#plots graph reactive to selected input
output$graph <- renderPlot(
if(input$overview == 'fez'){
FezPie(data())}
else{
YearPie(data())}
)
# TEMPORAL FIX -----------------------------------------------------------------------
# creates histogram and change table of pre and post temporal fix
output$hist <- renderPlot({
req(input$temporal)
# apply growth data to whole plot data by identifying AGB map year
plots <- data() #should be inside!
gez <- sort(as.vector((unique(plots$GEZ)))) #gets unique eco-zones without NAs
plotsNew <- ldply(lapply (1:length(gez), function(x)
TempFixed(plots, gez[[x]], 2010)), data.frame) #2010 = GlobBiomass year
# add plots with 1-2 NA from the "uniques" (it's just 0.06% of the total dataset)
plotsNew <- rbind(plotsNew, subset(plots, is.na(GEZ)))
HistoShift(plots, plotsNew)
})
output$table1 <- renderDT({
# apply growth data to whole plot data by identifying AGB map year
plots <- data() #should be inside!
gez <- sort(as.vector((unique(plots$GEZ)))) #gets unique eco-zones without NAs
plotsNew <- ldply(lapply (1:length(gez), function(x)
TempFixed(plots, gez[[x]], 2010)), data.frame) #2010 = GlobBiomass year
# add plots with 1-2 NA from the "uniques" (it's just 0.06% of the total dataset)
plotsNew <- rbind(plotsNew, subset(plots, is.na(GEZ)))
ChangeTable(plots, plotsNew)
# export new AGB data according to date generated
# write.csv(plotsNew, paste0('GlobBiomass_validation_data_600_TempFixed_',Sys.Date(),'.csv'), row.names=FALSE)
})
# INVDASYMETRY -----------------------------------------------------------------------
# TF only ---------------------------------------
output$valid1 <- renderPlot({
req(input$temporal)
req(input$scale)
req(input$global)
req(input$aggregation)
if(input$temporal == 'yes'){
plots <- data()
gez <- sort(as.vector((unique(plots$GEZ))))
plotsNew <- ldply(lapply (1:length(gez), function(x)
TempFixed(plots, gez[[x]], 2010)), data.frame)
plotsNew <- rbind(plotsNew, subset(plots, is.na(GEZ)))
}else{
plotsNew <- data()
}
#Invdasymetry-------------------------------------
#COUNTRY
if(input$scale == 'global' & input$global == 'country'){
#yes TF, yes agg
if (input$aggregation == 'yes' & input$temporal == 'yes'){
AGBdata <- invDasymetry(plotsNew, "ZONE",  input$subglobal, input$obs1, 5)
save(AGBdata, file = file.path(outDir,
paste0("agg01_", input$subglobal, ".Rdata")))
}
#no TF, yes agg
if (input$aggregation == 'yes' & input$temporal == 'no'){
AGBdata <- invDasymetry(plotsNew, "ZONE",  input$subglobal, input$obs1, 5)
save(AGBdata, file = file.path(outDir,
paste0("agg01x_", input$subglobal, ".Rdata")))
}
#yes TF, no agg
if (input$aggregation == 'no' & input$temporal == 'yes'){
AGBdata <- invDasymetry(plotsNew, "ZONE", input$subglobal, wghts = T)
save(AGBdata, file = file.path(outDir,
paste0("InvDasyPlotx_", input$subglobal, ".Rdata")))
}
# no processing at all
if (input$aggregation == 'no' & input$temporal == 'no'){
AGBdata <- invDasymetry(plotsNew, "ZONE", input$subglobal, wghts = T)
save(AGBdata, file = file.path(outDir,
paste0("InvDasyPlot_", input$subglobal, ".Rdata")))
}
}
#BIOMES
if(input$scale == 'global' & input$global == 'biome'){
#conditions---------
if (input$aggregation == 'yes' & input$temporal == 'yes'){
AGBdata <- invDasymetry(plotsNew, "GEZ",  input$subglobal, input$obs1, 5)
save(AGBdata, file = file.path(outDir,
paste0("agg01_", input$subglobal, ".Rdata")))
}
#no TF, yes aggregation
if (input$aggregation == 'yes' & input$temporal == 'no'){
AGBdata <- invDasymetry(plotsNew, "GEZ",  input$subglobal, input$obs1, 5)
save(AGBdata, file = file.path(outDir,
paste0("agg01x_", input$subglobal, ".Rdata")))
}
#yes TF, no aggregation
if (input$aggregation == 'no' & input$temporal == 'yes'){
AGBdata <- invDasymetry(plotsNew, "GEZ", input$subglobal, wghts = T)
save(AGBdata, file = file.path(outDir,
paste0("InvDasyPlotx_", input$subglobal, ".Rdata")))
}
# if there's no processing at all
if (input$aggregation == 'no' & input$temporal == 'no'){
AGBdata <- invDasymetry(plotsNew, "GEZ", input$subglobal, wghts = T)
save(AGBdata, file = file.path(outDir,
paste0("InvDasyPlot_", input$subglobal, ".Rdata")))
}
}
#one plot
OnePlot(AGBdata$plotAGB_10, AGBdata$mapAGB,'Sample Plots')
})
# add accuracy table
output$accuracy1 <- renderDT({
#COUNTRY
if(input$scale == 'global' & input$global == 'country'){
#yes TF, yes agg (ideal)
if (input$aggregation == 'yes' & input$temporal == 'yes'){
Rdata <- list.files(outDir, pattern='agg01')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
#no TF, yes agg
if (input$aggregation == 'yes' & input$temporal == 'no'){
Rdata <- list.files(outDir, pattern='agg01x')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
#yes TF, no agg
if (input$aggregation == 'no' & input$temporal == 'yes'){
Rdata <- list.files(outDir, pattern='InvDasyPlotx_')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
# no processing at all
if (input$aggregation == 'no' & input$temporal == 'no'){
Rdata <- list.files(outDir, pattern='InvDasyPlot')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
}
#BIOME
if(input$scale == 'global' & input$global == 'biome'){
#yes TF, yes agg
if (input$aggregation == 'yes' & input$temporal == 'yes'){
Rdata <- list.files(outDir, pattern='agg01')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
#no TF, yes agg
if (input$aggregation == 'yes' & input$temporal == 'no'){
Rdata <- list.files(outDir, pattern='agg01x')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
#yes TF, no agg
if (input$aggregation == 'no' & input$temporal == 'yes'){
Rdata <- list.files(outDir, pattern='InvDasyPlotx_')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
# no processing at all
if (input$aggregation == 'no' & input$temporal == 'no'){
Rdata <- list.files(outDir, pattern='InvDasyPlot')
AGBdata <-get(load(paste0(outDir, '/', Rdata)))
}
}
#metrics per bin
acc <- Accuracy(AGBdata, 6)
acc1 <- cbind (acc, old.bias = round((acc[4] - acc[3]), 2)) #bias column
names(acc1) <- c('AGB class (Mg/ha)','n (plots)', 'AGBref (Mg/ha)', 'AGBmap (Mg/ha)',
'RMSE (Mg/ha)', 'Rel.RMSE (%)', 'SD error (Mg/ha)',  'Bias (Mg/ha)')
acc1
})
# > 1 plots  ----------------------------
output$valid2 <- renderPlot({
# if baseline exist...
RdBase <- list.files(outDir, pattern='InvDasyPlot_')
if(length(RdBase) == 1 & input$comparison == 'yes'){
#get data
RdTemp <- list.files(outDir, pattern='InvDasyPlotx_')
RdAgg <- list.files(outDir, pattern='agg01x_')
RdBoth <- list.files(outDir, pattern='agg01_')
#both TF and Agg effects
if(length(RdBoth) == 1 & length(RdTemp) == 1){
#load only when file exist
AGBBase <-get(load(paste0(outDir, '/', RdBase)))
AGBTemp <-get(load(paste0(outDir, '/', RdTemp)))
AGBBoth <-get(load(paste0(outDir, '/', RdBoth)))
#three plots
ThreePlots(AGBBase$plotAGB_10, AGBBase$mapAGB, AGBTemp$plotAGB_10,AGBTemp$mapAGB,
AGBBoth$plotAGB_10,AGBBoth$mapAGB,'Sample plot',
fname=file.path(outDir, paste0("Effects_",Sys.Date(),".png")))
}
#TF effect, no Agg
if(length(RdTemp) == 1){
#two plots
}
#Agg effect, no TF
if(length(RdAgg) == 1){
#two plots
}
}
else{print('run baseline first (no TF - no Aggregation)')}
})
}
shinyApp(ui, server)
?setnames
library (data.table)
?setnames
